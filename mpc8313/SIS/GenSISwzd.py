#!/usr/bin/python
# -*- coding: iso-8859-1 -*-
################################################################################
#    IXXAT Automation GmbH      (all rights reserved)
################################################################################
#  $Workfile: $
#   $Archive: $
#  $Revision: 1.2 $
#      $Date: 2009/11/03 19:51:27PST $
#     Author:
#    Summary: see following doc-string
#
"""

"""

__revision__ = "1.00.01"

#--------------- Import Section --------------------------------------------
# standard library imports
# application specific imports
import math
import sys
#--------------- Constants -------------------------------------------------

#--------------- Variables -------------------------------------------------

#
#  SIScfg.wzd template
#
template = \
"""###########################################################################
##
##                         Wizard File for SIS V2
##
##  SIS source code will be generated by means of these definitions for:
##  - tasks
##  - error handling
##  - mailboxes
##  - memory pools
##  - events
##
##  Pay Attention to all marked sections. The marked sections are framed with:
##
##  //****************************
##  // important implemention hint
##  //****************************
##
############################################################################
############################################################################


// Task definition:
// Remark: higher priority tasks at the top !
// TASK( <hdl>,     <function>  )
// Mailbox definition:
// MBOX( <rx-task-hdl>, <number-of-entries>, [<tx-task-hdl>, ...] )

TASK( CTL_TSK,        CTL_Task )

%(MboxCtlTsk)s

%(SlaveTasks)s

%(TransparentTask)s

%(MasterSyncTasks)s

%(MasterDelayTasks)s

%(MasterAnncTasks)s

%(P2PTasks)s

//***********************************************
// one mandatory management task for one node
//***********************************************
TASK( MNT_TSK,      MNT_Task )

//******************************************************************
// one message box for the management task - 10 entries recommended
//******************************************************************
MBOX( MNT_TSK,   10 )

%(UnicastTasks)s

//***********************************************
// three mandatory dispatcher tasks for one node
//***********************************************
TASK( DIS_TSK,      DIS_Task )
TASK( DISnet_TSK,   DISnet_Task )
TASK( DISlat_TSK,   DISnet_Task )

//******************************************************************
// one message box for the dispatcher task - 20 entries recommended
//******************************************************************
MBOX( DIS_TSK,   20 )
MBOX( DISnet_TSK, 1)
MBOX( DISlat_TSK, 1)

// Memory definition:
// POOL( <pool-hdl>, [PUBL/PRIV],<number-of-entries>, <size> )

%(k_POOL64)s

%(k_POOL128)s

%(k_POOL256)s

%(k_POOL1536)s

// Event Definitions
// EVENT( <task-hdl>, <event> )
EVENT(CTL_TSK,k_EV_INIT,k_EV_SYN_TMT,k_EV_SC_SLV,k_EV_SC_PSV,k_EV_SC_MST,k_EV_SC_FLT,k_EV_SC_DSBL,k_EV_SC_ENBL,k_EV_SETPREF,k_EV_CLRPREF,k_EV_DONE,k_EV_SYNC,k_EV_FLT_CLRD)
"""

#--------------- Functions -------------------------------------------------
def readHeaderFile(filename):
    """
    Read C header file.
    """
    lines = file(filename).readlines()

    dInData = {
        'TRUE': True,
        'FALSE': False,
        'k_LITTLE': 1,
        'k_BIG': 0
    }
    for line in lines:
        line = line.strip()
        line = line.split('/*')[0]
        if len(line) > 7 and line[:7] == '#define':
            try:
                key, expr = line[8:].split(' ', 1)
            except:
                continue
            try:
                expr = expr.strip()
                value = eval(expr, {}, dInData)
            except:
                continue
            dInData[key] = value
    return dInData

def convertDataBase(dInData):
    """
    Convert data base
    """
    dOutData = {}

    if dInData['k_CLK_IS_TC'] == True:
        dOutData['TransparentTask'] = """//***********************************************
// TCS_TSK-definition for the node
// just used in (all) transparent clocks
//***********************************************
TASK( TCS_TSK,        TCFsyn_Task )

//******************************************************************
// one message box for the TCS task - 10 entries recommended
//******************************************************************
MBOX( TCS_TSK,  10 )
"""
        if dInData['k_CLK_DEL_E2E'] == True:
           dOutData['TransparentTask'] += """
//***********************************************
// TCD_TSK-definition for the node
// just used in end to end transparent clocks
//***********************************************
TASK( TCD_TSK,        TCFdel_Task )

//******************************************************************
// one message box for the TCS task - 10 entries recommended
//******************************************************************
MBOX( TCD_TSK,  10 )

//***********************************************
// TCP_TSK-definition for the node
// just used in end to end transparent clocks
// to forward P2P message
//***********************************************
TASK( TCP_TSK,        TCFp2p_Task )

//******************************************************************
// one message box for the TCS task - 10 entries recommended
//******************************************************************
MBOX( TCP_TSK,  10 )
"""
    else:
        dOutData['TransparentTask'] = ''
    if dInData['k_CLK_IS_OC'] == True or dInData['k_CLK_IS_BC'] == True:
        if dInData['k_CLK_DEL_E2E'] == True:
            dOutData['MboxCtlTsk'] = \
"""//******************************************************************
// insert SLS- and SLD-task-handles as tx-task-handles to CTL_TSK
//******************************************************************
MBOX( CTL_TSK,  10, MNT_TSK, SLS_TSK,SLD_TSK)"""
        else:
            dOutData['MboxCtlTsk'] = \
"""//******************************************************************
// insert SLS--task-handle as tx-task-handles to CTL_TSK
//******************************************************************
MBOX( CTL_TSK,  10, MNT_TSK, SLS_TSK)"
"""

        s = """//***********************************************
// one MSTsyn_Task-definition for each channel
// enumerate the tasks with the handles
// MAS1_TSK , MAS2_TSK ,..., MASn_TSK
// in ascending order
//***********************************************
"""
        for idx in range(0, dInData['k_NUM_IF']):
            s += 'TASK( MAS%u_TSK,       MSTsyn_Task )\n' % (idx+1)
            s += 'MBOX( MAS%u_TSK, 10 )\n' % (idx+1)
        dOutData['MasterSyncTasks'] = s

        s = """//***********************************************
// one MSTdel_Task-definition for each channel
// enumerate the tasks with the handles
// MAD1_TSK , MAD2_TSK ,..., MADn_TSK
// in ascending order
//***********************************************
"""
        for idx in range(0, dInData['k_NUM_IF']):
            s += 'TASK( MAD%u_TSK,       MSTdel_Task )\n' % (idx+1)
            s += 'MBOX( MAD%u_TSK, 10 )\n' % (idx+1)
        dOutData['MasterDelayTasks'] = s


        s = """//***********************************************
// one MSTdel_Task-definition for each channel
// enumerate the tasks with the handles
// MAD1_TSK , MAD2_TSK ,..., MADn_TSK
// in ascending order
//***********************************************
"""
        for idx in range(0, dInData['k_NUM_IF']):
            s += 'TASK( MAA%u_TSK,       MSTannc_Task )\n' % (idx+1)
            s += 'MBOX( MAA%u_TSK, 10 )\n' % (idx+1)
        dOutData['MasterAnncTasks'] = s

        dOutData['SlaveTasks'] = """//***********************************************
//  SLV_SyncTask-definition
//***********************************************
TASK( SLS_TSK,        SLV_SyncTask )
TASK( SLSintTmo_TSK,  SLV_SyncTask )
TASK( SLSrcvTmo_TSK,  SLV_SyncTask )

//******************************************************************
// one message box for the slave sync task - 10 entries recommended
//******************************************************************
MBOX( SLS_TSK      , 10 )
MBOX( SLSintTmo_TSK,  1 )
MBOX( SLSrcvTmo_TSK,  1 )
"""
        if dInData['k_CLK_DEL_E2E'] == True:
           dOutData['MboxCtlTsk'] += """
//***********************************************
// SLV_DelayTask-definition
//***********************************************
TASK( SLD_TSK,      SLV_DelayTask )

//******************************************************************
// one message box for the slave delay task - 10 entries recommended
//******************************************************************
MBOX( SLD_TSK,  10 )

//***********************************************
// CLK_Task-definition
//***********************************************
TASK( CLK_TSK, CLK_Task )
TASK( CLKTmo_TSK, CLK_Task )"""
    else:
        dOutData['MboxCtlTsk'] = """//******************************************************************
// insert SLS- and SLD-task-handles as tx-task-handles to CTL_TSK
//******************************************************************
MBOX( CTL_TSK,  10, MNT_TSK)"""
        dOutData['MasterSyncTasks'] = ''
        dOutData['MasterDelayTasks'] = ''
        dOutData['MasterAnncTasks'] = ''
        dOutData['SlaveTasks'] = ''

    if((dInData['k_UNICAST_CPBL'] == True) and ((dInData['k_CLK_IS_OC'] == True)or(dInData['k_CLK_IS_BC'] == True))):

        dOutData['UnicastTasks'] = """//***********************************************
// UCM task definitions for the node
// just used in unicast capable clocks
//***********************************************
TASK( UCMann_TSK,        UCMann_Task )
TASK( UCMsyn_TSK,        UCMsyn_Task )
TASK( UCMdel_TSK,        UCMdel_Task )

//***********************************************
// UCD task definition for the node
// just used in unicast capable clocks
//***********************************************
TASK( UCD_TSK,           UCD_Task )

//******************************************************************
// one message box for the unicast announce task - 3 entries recommended
//******************************************************************
MBOX( UCMann_TSK,   3 )

//******************************************************************
// one message box for the unicast sync task
// - 3 entries recommended
//******************************************************************
MBOX( UCMsyn_TSK,   3 )

//******************************************************************
// one message box for the unicast delay request task
// - 3 entries recommended
//******************************************************************
MBOX( UCMdel_TSK,   3 )

//******************************************************************
// one message box for the unicast discovery task
// - 10 entries recommended
//******************************************************************
MBOX( UCD_TSK,   1 )"""
    else:
        dOutData['UnicastTasks']=''

    if dInData['k_CLK_DEL_P2P'] == True:
        s = """//***********************************************
// P2P_PDelTask-definition for each channel
// just used in P2P clocks
//***********************************************
"""
        for idx in range(0, dInData['k_NUM_IF']):
            s += 'TASK( P2Pdel_TSK%u,       P2P_PDelTask )\n' % (idx+1)
            s += 'MBOX( P2Pdel_TSK%u,  10 )\n' % (idx+1)

        s+= """//***********************************************
// P2P_Prsp Task-definition for each channel
// just used in P2P clocks
//***********************************************
"""
        for idx in range(0, dInData['k_NUM_IF']):
            s += 'TASK( P2Prsp_TSK%u,       P2P_PrspTask )\n' % (idx+1)
            s += 'MBOX( P2Prsp_TSK%u,  10 )\n' % (idx+1)

        dOutData['P2PTasks'] = s
    else:
        dOutData['P2PTasks'] =''

## dynamic memory pools
    num_64_pools   = dInData['k_NUM_IF'] * 5
    num_128_pools  = dInData['k_NUM_IF'] * 5
    num_256_pools  = dInData['k_NUM_IF'] * 5
    num_1536_pools = 2
    ## memory for TC table sync
    if dInData['k_CLK_IS_TC'] == True:
        ## calculate needed memory size for sync structs
        mem_size_sync = 36 + (dInData['k_NUM_IF'] * 13)
        ## align size to dword
        mem_size_sync += 3
        mem_size_sync = math.floor(mem_size_sync / 4)
        mem_size_sync *= 4
        
        amnt_needed_buffers = math.ceil(dInData['k_AMNT_SYN_COR'] * dInData['k_NUM_IF'] / 4)
        
        if mem_size_sync <= 64:
          num_64_pools  += amnt_needed_buffers
        elif mem_size_sync <= 128:
          num_128_pools += amnt_needed_buffers
        elif mem_size_sync <= 256:
          num_256_pools += amnt_needed_buffers
        elif mem_size_sync <= 1536:
          num_1536_pools += amnt_needed_buffers
        else:
          raise 'No Buffers implemented'

        
        ## memory for TC table delay request and P2P forwarding
        if dInData['k_CLK_DEL_E2E'] == True:
            ## calculate needed memory size for delay structs
            mem_size_del = 30 + (dInData['k_NUM_IF'] * 12)
            ## align size to dword
            mem_size_del += 3
            mem_size_del = math.floor(mem_size_del / 4)
            mem_size_del *= 4
            amnt_needed_buffers = math.ceil(dInData['k_AMNT_P2P_COR'] * dInData['k_NUM_IF'] / 4)

            if mem_size_del <= 64:
              num_64_pools  += amnt_needed_buffers
            elif mem_size_del <= 128:
              num_128_pools += amnt_needed_buffers
            elif mem_size_del <= 256:
              num_256_pools += amnt_needed_buffers
            elif mem_size_del <= 1536:
              num_1536_pools += amnt_needed_buffers
            else:
              raise 'No Buffers implemented'


    if((dInData['k_UNICAST_CPBL'] == True) and ((dInData['k_CLK_IS_OC'] == True)or(dInData['k_CLK_IS_BC'] == True))):
        num_64_pools  += dInData['k_MAX_UC_MST_TBL_SZE']
        num_128_pools += 3
        num_256_pools += 1
        
##############################################################################
## Change memory pool configuration if needed here
##############################################################################
    num_64_pools += 1
    num_128_pools += 1
    num_256_pools += 1

    
    dOutData['k_POOL64'] = """//******************************************************************
// pool for memory up to 64 byte
//******************************************************************
POOL( k_POOL_64, PUBL, %u, 64)""" %num_64_pools

    dOutData['k_POOL128'] = """//******************************************************************
// pool for memory up to 128 byte
//******************************************************************
POOL( k_POOL_128, PUBL, %u, 128)""" %num_128_pools

    dOutData['k_POOL256'] = """//******************************************************************
// pool for memory up to 256 byte
//******************************************************************
POOL( k_POOL_256, PUBL, %u, 256)""" %num_256_pools

    dOutData['k_POOL1536'] = """//******************************************************************
// pool for memory up to 1536 byte
//******************************************************************
POOL( k_POOL_1536, PUBL, %u, 1536)""" %num_1536_pools

    return dOutData

def generateOutputFile(filename, template, dOutData):
    """
    Generate target file by means of 'template' and 'dOutData'.
    """
    file(filename, 'wt').write(template % dOutData)

#--------------- Main ------------------------------------------------------
if __name__ == '__main__':
    data = readHeaderFile(sys.argv[1])
    data = convertDataBase(data)
    generateOutputFile('SIScfg.wzd', template, data)

